/**
 * Basic declarations for the npm modules we use.
 */

declare module "micromatch" {
  declare module.exports: {
    (Array<string>, Array<string>, ?{ nocase: boolean }): Array<string>,
  };
}

declare module "resolve" {
  declare export default {
    sync: (string, {| basedir: string |}) => string;
  };
}

declare module "json5" {
  declare export default {
    parse: (string) => mixed,
  };
}

declare module "glob" {
  declare module.exports: {
    sync(pattern: string): Array<string>,
  };
}
declare module "slash" {
  declare module.exports: {
    (filepath: string): string,
  };
}

declare module "commander" {
  declare class Options { }

  declare class Command {
    static Command: Class<Command>;
    static Option: Class<Option>;

    args: Array<string>;

    arguments(desc: string): this;
    parseExpectedArgs(args: Array<string>): this;

    command(name: string, opts: Options): Command;
    command(name: string, desc: string, opts: Options): Command;
    addImplicitHelpCommand(): Command;

    action(cb: () => mixed): this;
    option<T>(
      flags: string,
      desc: string,
      fn?: RegExp | (value: string, prevValue: T) => T,
      defaultValue?: T,
    ): this;
    option(
      flags: string,
      desc: string,
      defaultValue: any,
    ): this;
    allowUnknownOption(name: string): this;

    parse(argv: Array<string>): this;
    parseOptions(argv: Array<string>): {
      args: Array<string>,
      unknown: Array<string>,
    };

    opts(): {
      [string]: mixed,
    };
    version(str: string, flags?: string): this;
    description(): string;
    description(str: string): this;
    alias(): string;
    alias(str: string): this;
    usage(): string;
    usage(str: string): this;
    name(): string;
    name(str: string): this;
    outputHelp<T>(cb?: T => T): void;
    help<T>(cb?: T => T): void;
  }

  declare class Option {
    name(): string;
    attributeName(): string;
    is(name: string, opts: Options): boolean;
  }

  declare module.exports: Command;
}

declare module "chokidar" {
  declare type Paths = string | Array<string>;
  declare type Options = {
    persistent?: boolean,
    ignoreInitial?: boolean,
    ignorePermissionErrors?: boolean,
    interval?: number,
    binaryInterval?: number,
    disableGlobbing?: boolean,
    useFsEvents?: boolean,
    usePolling?: boolean,
    atomic?: boolean | number,
    awaitWriteFinish?: {
      stabilityThreshold?: number,
      pollInterval?: number,
    } | boolean,
    ignored?: Paths,
    followSymlinks?: boolean,
    cwd?: string,
    alwaysStat?: boolean,
  };

  declare type EventType =
    | 'add'
    | 'addDir'
    | 'change'
    | 'unlink'
    | 'unlinkDir';

  declare class FSWatcher {
    constructor(opts: ?Options): this;
    add(paths: Paths): this;
    unwatch(paths: Paths): this;
    close(): this;
    getWatched(): {
      [string]: Array<string>,
    };
    on("all", (type: EventType, path: string) => mixed): this;
    on("add", (path: string) => mixed): this;
    on("change", (path: string) => mixed): this;
  }

  declare module.exports: {
    FSWatcher: Class<FSWatcher>,
    watch(paths: Paths, options: ?Options): FSWatcher,
  };
}
declare module "fs-readdir-recursive" {
  declare module.exports: {
    (
      root: string,
      filter?: ?(name: string, index: number, dir: string) => boolean,
      files?: ?Array<string>,
      prefix?: ?string,
    ): Array<string>;
  };
}
declare module "output-file-sync" {
  declare module.exports: {
    (filepath: string, content: string): void;
  };
}

declare module "lodash/uniq" {
  declare export default <T>(items: Array<T>) => Array<T>;
}
declare module "lodash/includes" {
  declare export default <T>(items: Array<T>, item: T) => boolean;
}
declare module "lodash/defaults" {
  declare export default <T: Object>(T, Object) => T;
}
declare module "lodash/clone" {
  declare export default <T>(obj: T) => T;
}
declare module "lodash/cloneDeep" {
  declare export default <T>(obj: T) => T;
}
declare module "lodash/escapeRegExp" {
  declare export default (obj: string) => string;
}
declare module "lodash/merge" {
  declare export default <T: Object>(T, Object) => T;
}
declare module "pirates" {
  declare export type Hook = (code: string, filename: string) => string;
  declare export type RevertHook = () => mixed;
  declare export type Options = {
    extensions?: ?Array<string>,
    extension?: ?Array<string>,
    exts?: ?Array<string>,
    ext?: ?Array<string>,
    ignoreNodeModules?: ?boolean,
    matcher?: ?(filepath: string) => boolean,
  };

  declare export function addHook(hook: Hook, opts?: Options): RevertHook
}
declare module "source-map-support" {
  declare type RetrievedMap = {
    url: ?string,
    map: string | Object,
  };

  declare type Options = {
    environment?: string,
    handleUncaughtExceptions?: boolean,
    retrieveFile?: (filepath: string) => ?string,
    overrideRetrieveFile?: boolean,
    retrieveSourceMap?: (source: string) => ?RetrievedMap,
    overrideRetrieveSourceMap?: boolean,
    hookRequire?: boolean,
    emptyCacheBetweenOperations?: boolean,
  };

  declare module.exports: {
    install(opts?: ?Options): void,
  };
}

declare module "find-cache-dir" {
  declare module.exports: {
    ({ name: string }): string,
  };
}

declare module "home-or-tmp" {
  declare module.exports: string;
}

declare module "esutils" {
  declare module.exports: {
    keyword: {
      isReservedWordES6(ident: string, strict?: boolean): boolean,
      isIdentifierNameES6(ident: string): boolean,
    },
  };
}

declare module "js-tokens" {
  declare export type InvalidToken = {
    type: "invalid",
    value: "string",
  };
  declare export type StringToken = {
    type: "string",
    value: "string",
  };
  declare export type CommentToken = {
    type: "comment",
    value: "string",
    closed: boolean | void,
  };
  declare export type RegexToken = {
    type: "regex",
    value: "string",
  };
  declare export type NumberToken = {
    type: "number",
    value: "string",
  };
  declare export type NameToken = {
    type: "name",
    value: "string",
  };
  declare export type PunctuatorToken = {
    type: "punctuator",
    value: "string",
  };
  declare export type WhitespaceToken = {
    type: "whitespace",
    value: "string",
  };

  declare export type Token =
    | InvalidToken
    | StringToken
    | CommentToken
    | RegexToken
    | NumberToken
    | NameToken
    | PunctuatorToken
    | WhitespaceToken;

  declare export default RegExp;
  declare export function matchToToken(match: Array<string>): Token;
}

declare module "semver" {
  declare module.exports: {
    valid(v: string): boolean;
    gt(v1: string, v2: string): boolean;
    lt(v1: string, v2: string): boolean;
    major(v: string): number;
    minor(v: string): number;
    patch(v: string): number;
    satisfies(v1: string, r1: string): boolean;

    intersects(r1: string, r2: string): boolean;
  }
}

declare module "source-map" {
  declare export type SourceMap = {
    version: 3,
    file: ?string,
    sourceRoot: ?string,
    sources: [?string],
    sourcesContent: [?string],
    names: [?string],
    mappings: string,
  };

  declare module.exports: {
    SourceMapConsumer: typeof SourceMapConsumer,
    SourceMapGenerator: typeof SourceMapGenerator,
  }

  declare class SourceMapConsumer {
    static GENERATED_ORDER: 1;
    static ORIGINAL_ORDER: 2;

    file: string | null;
    sourceRoot: string | null;
    sources: Array<string>;

    constructor(?SourceMap): this;

    computeColumnSpans(): string;
    originalPositionFor({
      line: number,
      column: number,
    }): {|
      source: string,
      line: number,
      column: number,
      name: string | null
    |} | {|
      source: null,
      line: null,
      column: null,
      name: null
    |};

    generatedPositionFor({
      source: string,
      line: number,
      column: number,
    }): {|
      line: number,
      column: number,
      lastColumn: number | null | void,
    |} | {|
      line: null,
      column: null,
      lastColumn: null | void,
    |};

    allGeneratedPositionsFor({
      source: string,
      line: number,
      column: number,
    }): Array<{|
      line: number,
      column: number,
      lastColumn: number,
    |}>;

    sourceContentFor(string, boolean | void): string | null;

    eachMapping(
      ({|
        generatedLine: number,
        generatedColumn: number,
        source: string,
        originalLine: number,
        originalColumn: number,
        name: string | null,
      |} | {|
        generatedLine: number,
        generatedColumn: number,
        source: null,
        originalLine: null,
        originalColumn: null,
        name: null,
      |}) => mixed,
      context: mixed,
      order: ?(1 | 2),
    ): void;
  }

  declare class SourceMapGenerator {
    constructor(?{
      file?: string | null,
      sourceRoot?: string | null,
      skipValidation?: boolean | null,
    }): this;

    addMapping({
      generated: {
        line: number,
        column: number,
      }
    }): void;

    setSourceContent(string, string): void;

    toJSON(): SourceMap;
  }
}

declare module "convert-source-map" {
  import type { SourceMap } from "source-map";

  declare class Converter {
    toJSON(): string;
    toBase64(): string;
    toComment(): string;
    toObject(): SourceMap
  }

  declare module.exports: {
    SourceMap: SourceMap,
    Converter: Converter,
    fromObject(obj: SourceMap): Converter,
    fromJSON(str: string): Converter,
    fromBase64(str: string): Converter,
    fromComment(str: string): Converter,
    fromMapFileComment(str: string): Converter,
    fromSource(str: string): Converter,
    fromMapFileSource(str: string, dir: string): Converter,
    removeComments(str: string): string,
    removeMapFileComments(str: string): string,
    generateMapFileComment(path: string, options?: ?{ multiline: boolean }): string,
  };
}

declare module "js-levenshtein" {
  declare module.exports: {
    (string, string): number,
  };
}
